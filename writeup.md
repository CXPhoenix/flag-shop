# 旗幟商店 (Flag Shop)

## CTF Challenge Info
- **CTF**: Cybersecurity Easy to Learn (ch1_easy-chall)
- **Category**: Web / Logic Flaw
- **Points**: Easy
- **題目描述**: 這是一個入門級的 Web CTF 挑戰，目標是找出隱藏在商店中的 Flag。


## TL;DR

這題核心考驗對購物車邏輯漏洞（CWE-1284）的理解。只要趁著前端能任意更改商品數量的漏洞，買一個高價的 Flag，再加上數量為極大負數的便宜商品，就能讓結帳總金額變成 0，藉此繞過系統的餘額檢查，不花一毛錢把 Flag 買下來。以下為解題歷程：

### 解題歷程

| 你看到什麼（Observe） | 你覺得怎麼做（Do） | 結果（Result） |
|---|---|---|
| 帳戶餘額只有 $100，但 Flag 標價 $1,000 | 推測存在邏輯漏洞或參數竄改的可能，開始分析 | 確認目標：不花錢買下 Flag |
| `utils/crypto.js` 中有大量混淆的加解密函式（如 `_0x5a1b`） | 嘗試逆向破解，想直接從靜態檔案中取得 Flag | 死路：無金鑰無法解密，且 Flag 只在成功購買後才解密 |
| 前端數量輸入框不允許輸入負數，顯示「❌ 輸入錯誤：數量不能為小數！」 | 懷疑後端驗證也一樣嚴格，準備轉向找 SQLi / XSS | 做了其他嘗試，但意識到這只是前端防護，核心邏輯未必有同樣的驗證 |
| `store.js` 的 `checkout()` 擋住了 `total < 0` 與 `total > balance` 兩種情況，但似乎沒有擋住單獨物品是否為負值的情形。 | 嘗試放入 `CTF FLAG` 與 `駭客機械鍵盤`，並設定 `駭客機械鍵盤` 的數量變成 `-1`，看看能不能成功。 | 總額變成了 `990`，表示系統可以接受在`總額 >= 0` 時的物品的數量與小計為負的，計算上不會特別限制、處理。 |
| 基於以上觀察，確認可以透過物品小計金額互相抵銷而進行購買。 | 設定 `CTF FLAG` 物品為 1 個，`駭客機械鍵盤` 為 `-100` 個，讓最終結帳總額為 `0` | 成功繞過餘額限制，取得 Flag：`FLAG{Y0u_B0ught_Th3_Fl4g_W1th_N3gqt1v3_M0n3y}` |

## 完整 Writeup 歷程

### 初步偵查

進到題目網頁，外觀就像是個普通的線上商店。目標很明確：我們要把那個超出帳戶餘額的 Flag 商品買下來。稍微看了一下初始狀態，身上的餘額只有 $100，但 Flag 的標價卻高達 $1,000。直覺告訴我這大概是某種邏輯漏洞，或者是必須去竄改前端傳送的參數來變更價格。

### 死路與折返

剛開始在看前端原始碼時，在 `utils/crypto.js` 看到一段混淆得很誇張的加解密函式（像是 `_0x5a1b` 這種奇怪的命名），想說該不會 Flag 就藏在某個靜態檔案裡，等著我去逆向破解它？這想法浪費了一點時間，後來意識到就算逆向出演算法，沒有金鑰也是白搭。原來這只是單純用來保護 Flag 不被直接從原始碼搜出來，只要順利完成「購買」，系統就會自動幫我們解密。

另外一個陷阱是輸入框的前端驗證。試著在網頁的數量欄位打上負數，結果 UI 畫面直接跳出「❌ 輸入錯誤：數量不能為小數！」完全不讓我點結帳。當下還以為數量檢驗做得很完善，所以嘗試改為去找 SQL injection 或是 XSS 的後，才猛然發覺：等一下，這只是在攔截 UI 輸入的前端防護而已啊！

### 分析購物車邏輯

為了釐清這個商店底層到底是怎麼運算的，打開瀏覽器的開發者工具（F12）仔細看了一遍 `assets/js/store.js`。裡面的 `checkout()` 函式馬上吸引了我的注意：

```javascript
checkout() {
    const total = this.cartTotal;
    
    // 檢查 1: 總金額不能小於 0
    if (total < 0) { ... return { success: false }; }

    // 檢查 2: 餘額不足
    if (total > this.state.balance) { ... return { success: false }; }

    // 扣款並解密
    this.state.balance -= total;
    ...
}
```

這個結帳邏輯防了總額小於 0 的情況，也同時防了餘額不足。但我注意到它只驗證了**最終的加總結果**，並沒有對每件個別商品的小計是否為負值做任何檢查。

### 關鍵突破

為了驗證這個猜測，我把 `CTF FLAG` 和 `駭客機械鍵盤` 都加進購物車，並把 `駭客機械鍵盤` 的數量設為 `-1`。結果總額變成了 `$990`，系統完全沒有報錯，順利接受了這筆負數小計。這就確認了：只要整體總金額維持在 `>= 0` 的範圍內，系統對單一商品的小計為負值是不做任何限制的。

既然如此，只要讓兩件商品的金額互相抵銷，讓結帳總額歸零，就能同時繞過 `total < 0` 和 `total > balance` 這兩道防線了。


## Exploit / Payload

由於購物車介面本身就可以直接操作負數的部分，因此：

1. 將 `CTF FLAG` 與 `駭客機械鍵盤` 都加入購物車。

2. 點開購物車，直接在 `駭客機械鍵盤` 的數量欄位輸入 `-100`。

3. 此時購物車的總金額會自動更新為 `$0`（`$1000 + $-1000 = $0`）。

4. 直接點擊**確認結帳**按鈕即可。

這樣操作就成功繞過餘額限制，取得 Flag：

![Exploit Verification](./img/flag.png)

## Flag

```plaintext
FLAG{Y0u_B0ught_Th3_Fl4g_W1th_N3gqt1v3_M0n3y}
```

## Pattern Card

**這題教了什麼：**

- **前提條件**：系統允許商品數量為負值（通常是因為只做了前端防護，而後端或核心邏輯沒有再次驗證），並且結帳時允許多個商品並存，產生價格互相抵銷的效果。
- **嗅覺線索**：看到購物車有前端的攔截提示，或是攔截 API 請求後發現可以隨意竄改數量參數時，第一時間可以試著送出 `-1` 或是字串、浮點數等意料之外的格式來戳戳看。
- **現實意義**：這對應到真實世界的安全問題 [CWE-1284: Improper Validation of Specified Quantity in Input](https://cwe.mitre.org/data/definitions/1284.html)。電商平台的購物車如果沒有在伺服器端嚴格要求 `qty > 0`，且沒有確保每項商品的小計都不為負數，惡意使用者就能用類似手法買走高價商品甚至「洗錢」。正確的做法應該是在 `updateCartItemQty` 這類層級直接拒絕並拋出例外（throw error）。

## References

- [CWE-1284: Improper Validation of Specified Quantity in Input](https://cwe.mitre.org/data/definitions/1284.html)
